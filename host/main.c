#include <err.h>
#include <stdio.h>
#include <string.h>

/* OP-TEE TEE client API (built by optee_client) */
#include <tee_client_api.h>

/* TA API: UUID and command IDs */
#include <aes_crypto_ta.h>

#include "aes_crypto.h"
#include "clearkey_platform.h" /* currently useless */

/* Map between OP TEE TA and OpenSSL */
#define AES_BLOCK_SIZE CTR_AES_BLOCK_SIZE

typedef uint8_t KeyId[AES_BLOCK_SIZE];
typedef uint8_t Iv[AES_BLOCK_SIZE];

typedef struct
{
    uint8_t array[AES_BLOCK_SIZE];
    size_t size;
    size_t capacity;
} Vector;

typedef struct
{
    Vector *keys;
    Vector *values;
} KeyMap;

typedef struct
{
    uint8_t array[AES_BLOCK_SIZE];
    size_t size;
    size_t capacity;
} Key;

typedef struct
{
    KeyId key;
    Iv iv;
    uint8_t *source;
    uint8_t *destination;
    sub_sample_t *subSamples;
    size_t numSubSamples;
    size_t *bytesDecryptedOut;
} AesCtrDecryptorTest;

static int test_num = 0;

void attemptDecrypt(Key *key, Iv *iv, uint8_t *source,
                    uint8_t *destination, sub_sample_t *subSamples,
                    size_t numSubSamples, size_t *bytesDecryptedOut, size_t totalSize)
{
    Vector keyVector;
    uint32_t blockOffset = 0;
    uint8_t previousEncryptedCounter[AES_BLOCK_SIZE];
    size_t offset = 0, prev_offset = 0, clear_offset = 0;
    Iv opensslIv;
    uint8_t *previousOutput, *initialBuffer;

    previousOutput = malloc(totalSize);
    if (previousOutput == NULL)
    {
        printf("Decryption failed: could not allocate previous output buffer\n");
        return;
    }
    memset(previousOutput, 0, totalSize);

    initialBuffer = malloc(totalSize);
    if (initialBuffer == NULL)
    {
        printf("Decryption failed: could not allocate initial buffer\n");
        free(previousOutput);
        return;
    }
    memset(initialBuffer, 0, totalSize);
    memcpy(initialBuffer, source, totalSize);

    memcpy(keyVector.array, key->array, sizeof(keyVector.array));
    keyVector.size = AES_BLOCK_SIZE;
    keyVector.capacity = AES_BLOCK_SIZE;

    memset(previousEncryptedCounter, 0, AES_BLOCK_SIZE);

    memcpy(opensslIv, *iv, sizeof(opensslIv));

    // printf("offset: %d\n", offset);
    // printf("source: ");
    // for (size_t i = 0; i < totalSize; i++)
    // {
    //     printf("%02x ", source[i]);
    // }
    // printf("\n");
    // printf("destination: ");
    // for (size_t i = 0; i < totalSize; i++)
    // {
    //     printf("%02x ", destination[i]);
    // }
    // printf("\n");

    for (size_t i = 0; i < numSubSamples; ++i)
    {
        sub_sample_t *subSample = &subSamples[i];
        if (subSample->clear_bytes > 0)
        {
            memcpy(destination + offset, source + offset,
                   subSample->clear_bytes);
            offset += subSample->clear_bytes;
        }

        // printf("offset: %d\n", offset);
        // printf("source: ");
        // for (size_t i = 0; i < totalSize; i++)
        // {
        //     printf("%02x ", source[i]);
        // }
        // printf("\n");
        // printf("destination: ");
        // for (size_t i = 0; i < totalSize; i++)
        // {
        //     printf("%02x ", destination[i]);
        // }
        // printf("\n");

        if (subSample->encrp_bytes > 0)
        {
            /* remove additional offset to fix errors */
            // TEE_AES_ctr128_encrypt(source + offset, destination + offset,
            //                        subSample->encrp_bytes, (const char *)keyVector.array,
            //                        opensslIv, previousEncryptedCounter,
            //                        &blockOffset, offset, false);
            TEE_AES_ctr128_encrypt(source, destination,
                                   subSample->encrp_bytes, (const char *)keyVector.array,
                                   opensslIv, previousEncryptedCounter,
                                   &blockOffset, offset, false);
            offset += subSample->encrp_bytes;
        }

        memcpy(destination, previousOutput, prev_offset);

        memcpy(previousOutput, destination, offset);

        prev_offset = offset;

        // printf("offset: %d\n", offset);
        // printf("previousEncryptedCounter: ");
        // for (size_t i = 0; i < AES_BLOCK_SIZE; i++)
        // {
        //     printf("%02x ", previousEncryptedCounter[i]);
        // }
        // printf("\n");
        // printf("source: ");
        // for (size_t i = 0; i < totalSize; i++)
        // {
        //     printf("%02x ", source[i]);
        // }
        // printf("\n");
        // printf("destination: ");
        // for (size_t i = 0; i < totalSize; i++)
        // {
        //     printf("%02x ", destination[i]);
        // }
        // printf("\n");
    }

    *bytesDecryptedOut = offset;

    free(previousOutput);
    previousOutput = NULL;

    for (size_t i = 0; i < numSubSamples; ++i)
    {
        sub_sample_t *subSample = &subSamples[i];
        if (subSample->clear_bytes > 0)
        {
            memcpy(destination + clear_offset, initialBuffer + clear_offset,
                   subSample->clear_bytes);
            clear_offset += subSample->clear_bytes;
        }

        if (subSample->encrp_bytes > 0)
        {
            clear_offset += subSample->encrp_bytes;
        }
    }

    free(initialBuffer);
    initialBuffer = NULL;
}

void attemptDecryptExpectingSuccess(Key *key, Iv *iv,
                                    uint8_t *encrypted,
                                    uint8_t *decrypted,
                                    sub_sample_t *subSamples,
                                    size_t numSubSamples, size_t totalSize)
{
    uint8_t *outputBuffer;
    size_t bytesDecrypted = 0;

    outputBuffer = malloc(totalSize);
    if (outputBuffer == NULL)
    {
        printf("Decryption failed: could not allocate output buffer\n");
        return;
    }
    memset(outputBuffer, 0, totalSize);

    attemptDecrypt(key, iv, encrypted, outputBuffer,
                   subSamples, numSubSamples,
                   &bytesDecrypted, totalSize);
    if (bytesDecrypted != totalSize)
    {
        printf("Decryption failed: incorrect number of bytes decrypted\n");
        free(outputBuffer);
        return;
    }

    // for (size_t i = 0; i < totalSize; i++)
    // {
    //     printf("%02x ", outputBuffer[i]);
    // }
    // printf("\n");
    // for (size_t i = 0; i < totalSize; i++)
    // {
    //     printf("%02x ", decrypted[i]);
    // }
    // printf("\n");

    if (memcmp(outputBuffer, decrypted, totalSize) != 0)
    {
        printf("Decryption failed: decrypted data does not match expected data\n");
        free(outputBuffer);
        return;
    }

    printf("Decryption succeeded\n");
    free(outputBuffer);
    outputBuffer = NULL;

    test_num++;
}

void DecryptsContiguousEncryptedBlock(void)
{

#define TOTAL_SIZE 64
#define NUM_SUBSAMPLES 1

    // Test vectors from NIST-800-38A
    Key key = {
        .array = {
            0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6,
            0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c},
        .size = AES_BLOCK_SIZE,
        .capacity = AES_BLOCK_SIZE};
    Iv iv = {
        0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7,
        0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff};
    uint8_t encrypted[TOTAL_SIZE] = {
        0x87, 0x4d, 0x61, 0x91, 0xb6, 0x20, 0xe3, 0x26,
        0x1b, 0xef, 0x68, 0x64, 0x99, 0x0d, 0xb6, 0xce,
        0x98, 0x06, 0xf6, 0x6b, 0x79, 0x70, 0xfd, 0xff,
        0x86, 0x17, 0x18, 0x7b, 0xb9, 0xff, 0xfd, 0xff,
        0x5a, 0xe4, 0xdf, 0x3e, 0xdb, 0xd5, 0xd3, 0x5e,
        0x5b, 0x4f, 0x09, 0x02, 0x0d, 0xb0, 0x3e, 0xab,
        0x1e, 0x03, 0x1d, 0xda, 0x2f, 0xbe, 0x03, 0xd1,
        0x79, 0x21, 0x70, 0xa0, 0xf3, 0x00, 0x9c, 0xee};
    uint8_t decrypted[TOTAL_SIZE] = {
        0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96,
        0xe9, 0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a,
        0xae, 0x2d, 0x8a, 0x57, 0x1e, 0x03, 0xac, 0x9c,
        0x9e, 0xb7, 0x6f, 0xac, 0x45, 0xaf, 0x8e, 0x51,
        0x30, 0xc8, 0x1c, 0x46, 0xa3, 0x5c, 0xe4, 0x11,
        0xe5, 0xfb, 0xc1, 0x19, 0x1a, 0x0a, 0x52, 0xef,
        0xf6, 0x9f, 0x24, 0x45, 0xdf, 0x4f, 0x9b, 0x17,
        0xad, 0x2b, 0x41, 0x7b, 0xe6, 0x6c, 0x37, 0x10};
    sub_sample_t subSamples[NUM_SUBSAMPLES] = {
        {0, 64}};

    printf("TEST #%d DecryptsContiguousEncryptedBlock\n", test_num);

    TEE_crypto_init();
    attemptDecryptExpectingSuccess(&key, &iv, encrypted, decrypted,
                                   subSamples, NUM_SUBSAMPLES, TOTAL_SIZE);
    TEE_crypto_close();
}

void DecryptsAlignedBifurcatedEncryptedBlock(void)
{

#define TOTAL_SIZE 64
#define NUM_SUBSAMPLES 2

    // Test vectors from NIST-800-38A
    Key key = {
        .array = {
            0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6,
            0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c},
        .size = AES_BLOCK_SIZE,
        .capacity = AES_BLOCK_SIZE};

    Iv iv = {
        0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7,
        0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff};

    uint8_t encrypted[TOTAL_SIZE] = {
        0x87, 0x4d, 0x61, 0x91, 0xb6, 0x20, 0xe3, 0x26,
        0x1b, 0xef, 0x68, 0x64, 0x99, 0x0d, 0xb6, 0xce,
        0x98, 0x06, 0xf6, 0x6b, 0x79, 0x70, 0xfd, 0xff,
        0x86, 0x17, 0x18, 0x7b, 0xb9, 0xff, 0xfd, 0xff,
        0x5a, 0xe4, 0xdf, 0x3e, 0xdb, 0xd5, 0xd3, 0x5e,
        0x5b, 0x4f, 0x09, 0x02, 0x0d, 0xb0, 0x3e, 0xab,
        0x1e, 0x03, 0x1d, 0xda, 0x2f, 0xbe, 0x03, 0xd1,
        0x79, 0x21, 0x70, 0xa0, 0xf3, 0x00, 0x9c, 0xee};

    uint8_t decrypted[TOTAL_SIZE] = {
        0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96,
        0xe9, 0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a,
        0xae, 0x2d, 0x8a, 0x57, 0x1e, 0x03, 0xac, 0x9c,
        0x9e, 0xb7, 0x6f, 0xac, 0x45, 0xaf, 0x8e, 0x51,
        0x30, 0xc8, 0x1c, 0x46, 0xa3, 0x5c, 0xe4, 0x11,
        0xe5, 0xfb, 0xc1, 0x19, 0x1a, 0x0a, 0x52, 0xef,
        0xf6, 0x9f, 0x24, 0x45, 0xdf, 0x4f, 0x9b, 0x17,
        0xad, 0x2b, 0x41, 0x7b, 0xe6, 0x6c, 0x37, 0x10};

    sub_sample_t subSamples[NUM_SUBSAMPLES] = {
        {0, 32},
        {0, 32}};

    printf("TEST #%d DecryptsAlignedBifurcatedEncryptedBlock\n", test_num);

    TEE_crypto_init();
    attemptDecryptExpectingSuccess(&key, &iv, encrypted, decrypted,
                                   subSamples, NUM_SUBSAMPLES, TOTAL_SIZE);
    TEE_crypto_close();
}

void DecryptsUnalignedBifurcatedEncryptedBlock(void)
{

#define TOTAL_SIZE 64
#define NUM_SUBSAMPLES 2

    // Test vectors from NIST-800-38A
    Key key = {
        .array = {
            0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6,
            0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c},
        .size = AES_BLOCK_SIZE,
        .capacity = AES_BLOCK_SIZE};

    Iv iv = {
        0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7,
        0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff};

    uint8_t encrypted[TOTAL_SIZE] = {
        0x87, 0x4d, 0x61, 0x91, 0xb6, 0x20, 0xe3, 0x26,
        0x1b, 0xef, 0x68, 0x64, 0x99, 0x0d, 0xb6, 0xce,
        0x98, 0x06, 0xf6, 0x6b, 0x79, 0x70, 0xfd, 0xff,
        0x86, 0x17, 0x18, 0x7b, 0xb9, 0xff, 0xfd, 0xff,
        0x5a, 0xe4, 0xdf, 0x3e, 0xdb, 0xd5, 0xd3, 0x5e,
        0x5b, 0x4f, 0x09, 0x02, 0x0d, 0xb0, 0x3e, 0xab,
        0x1e, 0x03, 0x1d, 0xda, 0x2f, 0xbe, 0x03, 0xd1,
        0x79, 0x21, 0x70, 0xa0, 0xf3, 0x00, 0x9c, 0xee};

    uint8_t decrypted[TOTAL_SIZE] = {
        0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96,
        0xe9, 0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a,
        0xae, 0x2d, 0x8a, 0x57, 0x1e, 0x03, 0xac, 0x9c,
        0x9e, 0xb7, 0x6f, 0xac, 0x45, 0xaf, 0x8e, 0x51,
        0x30, 0xc8, 0x1c, 0x46, 0xa3, 0x5c, 0xe4, 0x11,
        0xe5, 0xfb, 0xc1, 0x19, 0x1a, 0x0a, 0x52, 0xef,
        0xf6, 0x9f, 0x24, 0x45, 0xdf, 0x4f, 0x9b, 0x17,
        0xad, 0x2b, 0x41, 0x7b, 0xe6, 0x6c, 0x37, 0x10};

    sub_sample_t subSamples[NUM_SUBSAMPLES] = {
        {0, 29},
        {0, 35}};

    printf("TEST #%d DecryptsUnalignedBifurcatedEncryptedBlock\n", test_num);

    TEE_crypto_init();
    attemptDecryptExpectingSuccess(&key, &iv, encrypted, decrypted,
                                   subSamples, NUM_SUBSAMPLES, TOTAL_SIZE);
    TEE_crypto_close();
}

void DecryptsOneMixedSubSample(void)
{

#define TOTAL_SIZE 72
#define NUM_SUBSAMPLES 1

    // Based on test vectors from NIST-800-38A
    Key key = {
        .array = {
            0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6,
            0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c},
        .size = AES_BLOCK_SIZE,
        .capacity = AES_BLOCK_SIZE};

    Iv iv = {
        0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7,
        0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff};

    uint8_t encrypted[TOTAL_SIZE] = {
        // 8 clear bytes
        0xf0, 0x13, 0xca, 0xc7, 0x00, 0x64, 0x0b, 0xbb,
        // 64 encrypted bytes
        0x87, 0x4d, 0x61, 0x91, 0xb6, 0x20, 0xe3, 0x26,
        0x1b, 0xef, 0x68, 0x64, 0x99, 0x0d, 0xb6, 0xce,
        0x98, 0x06, 0xf6, 0x6b, 0x79, 0x70, 0xfd, 0xff,
        0x86, 0x17, 0x18, 0x7b, 0xb9, 0xff, 0xfd, 0xff,
        0x5a, 0xe4, 0xdf, 0x3e, 0xdb, 0xd5, 0xd3, 0x5e,
        0x5b, 0x4f, 0x09, 0x02, 0x0d, 0xb0, 0x3e, 0xab,
        0x1e, 0x03, 0x1d, 0xda, 0x2f, 0xbe, 0x03, 0xd1,
        0x79, 0x21, 0x70, 0xa0, 0xf3, 0x00, 0x9c, 0xee};

    uint8_t decrypted[TOTAL_SIZE] = {
        0xf0, 0x13, 0xca, 0xc7, 0x00, 0x64, 0x0b, 0xbb,
        0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96,
        0xe9, 0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a,
        0xae, 0x2d, 0x8a, 0x57, 0x1e, 0x03, 0xac, 0x9c,
        0x9e, 0xb7, 0x6f, 0xac, 0x45, 0xaf, 0x8e, 0x51,
        0x30, 0xc8, 0x1c, 0x46, 0xa3, 0x5c, 0xe4, 0x11,
        0xe5, 0xfb, 0xc1, 0x19, 0x1a, 0x0a, 0x52, 0xef,
        0xf6, 0x9f, 0x24, 0x45, 0xdf, 0x4f, 0x9b, 0x17,
        0xad, 0x2b, 0x41, 0x7b, 0xe6, 0x6c, 0x37, 0x10};

    sub_sample_t subSamples[NUM_SUBSAMPLES] = {
        {8, 64}};

    printf("TEST #%d DecryptsOneMixedSubSample\n", test_num);

    TEE_crypto_init();
    attemptDecryptExpectingSuccess(&key, &iv, encrypted, decrypted,
                                   subSamples, NUM_SUBSAMPLES, TOTAL_SIZE);
    TEE_crypto_close();
}

void DecryptsAlignedMixedSubSamples(void)
{

#define TOTAL_SIZE 80
#define NUM_SUBSAMPLES 2

    // Based on test vectors from NIST-800-38A
    Key key = {
        .array = {
            0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6,
            0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c},
        .size = AES_BLOCK_SIZE,
        .capacity = AES_BLOCK_SIZE};

    Iv iv = {
        0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7,
        0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff};

    uint8_t encrypted[TOTAL_SIZE] = {
        // 8 clear bytes
        0xf0, 0x13, 0xca, 0xc7, 0x00, 0x64, 0x0b, 0xbb,
        // 32 encrypted bytes
        0x87, 0x4d, 0x61, 0x91, 0xb6, 0x20, 0xe3, 0x26,
        0x1b, 0xef, 0x68, 0x64, 0x99, 0x0d, 0xb6, 0xce,
        0x98, 0x06, 0xf6, 0x6b, 0x79, 0x70, 0xfd, 0xff,
        0x86, 0x17, 0x18, 0x7b, 0xb9, 0xff, 0xfd, 0xff,
        // 8 clear bytes
        0x94, 0xba, 0x88, 0x2e, 0x0e, 0x12, 0x11, 0x55,
        // 32 encrypted bytes
        0x5a, 0xe4, 0xdf, 0x3e, 0xdb, 0xd5, 0xd3, 0x5e,
        0x5b, 0x4f, 0x09, 0x02, 0x0d, 0xb0, 0x3e, 0xab,
        0x1e, 0x03, 0x1d, 0xda, 0x2f, 0xbe, 0x03, 0xd1,
        0x79, 0x21, 0x70, 0xa0, 0xf3, 0x00, 0x9c, 0xee};

    uint8_t decrypted[TOTAL_SIZE] = {
        0xf0, 0x13, 0xca, 0xc7, 0x00, 0x64, 0x0b, 0xbb,
        0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96,
        0xe9, 0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a,
        0xae, 0x2d, 0x8a, 0x57, 0x1e, 0x03, 0xac, 0x9c,
        0x9e, 0xb7, 0x6f, 0xac, 0x45, 0xaf, 0x8e, 0x51,
        0x94, 0xba, 0x88, 0x2e, 0x0e, 0x12, 0x11, 0x55,
        0x30, 0xc8, 0x1c, 0x46, 0xa3, 0x5c, 0xe4, 0x11,
        0xe5, 0xfb, 0xc1, 0x19, 0x1a, 0x0a, 0x52, 0xef,
        0xf6, 0x9f, 0x24, 0x45, 0xdf, 0x4f, 0x9b, 0x17,
        0xad, 0x2b, 0x41, 0x7b, 0xe6, 0x6c, 0x37, 0x10};

    sub_sample_t subSamples[NUM_SUBSAMPLES] = {
        {8, 32},
        {8, 32}};

    printf("TEST #%d DecryptsAlignedMixedSubSamples\n", test_num);

    TEE_crypto_init();
    attemptDecryptExpectingSuccess(&key, &iv, encrypted, decrypted,
                                   subSamples, NUM_SUBSAMPLES, TOTAL_SIZE);
    TEE_crypto_close();
}

void DecryptsUnalignedMixedSubSamples(void)
{

#define TOTAL_SIZE 80
#define NUM_SUBSAMPLES 2

    // Based on test vectors from NIST-800-38A
    Key key = {
        .array = {
            0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6,
            0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c},
        .size = AES_BLOCK_SIZE,
        .capacity = AES_BLOCK_SIZE};

    Iv iv = {
        0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7,
        0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff};

    uint8_t encrypted[TOTAL_SIZE] = {
        // 8 clear bytes
        0xf0, 0x13, 0xca, 0xc7, 0x00, 0x64, 0x0b, 0xbb,
        // 30 encrypted bytes
        0x87, 0x4d, 0x61, 0x91, 0xb6, 0x20, 0xe3, 0x26,
        0x1b, 0xef, 0x68, 0x64, 0x99, 0x0d, 0xb6, 0xce,
        0x98, 0x06, 0xf6, 0x6b, 0x79, 0x70, 0xfd, 0xff,
        0x86, 0x17, 0x18, 0x7b, 0xb9, 0xff,
        // 8 clear bytes
        0x94, 0xba, 0x88, 0x2e, 0x0e, 0x12, 0x11, 0x55,
        // 34 encrypted bytes
        0xfd, 0xff, 0x5a, 0xe4, 0xdf, 0x3e, 0xdb, 0xd5,
        0xd3, 0x5e, 0x5b, 0x4f, 0x09, 0x02, 0x0d, 0xb0,
        0x3e, 0xab, 0x1e, 0x03, 0x1d, 0xda, 0x2f, 0xbe,
        0x03, 0xd1, 0x79, 0x21, 0x70, 0xa0, 0xf3, 0x00,
        0x9c, 0xee};

    uint8_t decrypted[TOTAL_SIZE] = {
        0xf0, 0x13, 0xca, 0xc7, 0x00, 0x64, 0x0b, 0xbb,
        0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96,
        0xe9, 0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a,
        0xae, 0x2d, 0x8a, 0x57, 0x1e, 0x03, 0xac, 0x9c,
        0x9e, 0xb7, 0x6f, 0xac, 0x45, 0xaf, 0x94, 0xba,
        0x88, 0x2e, 0x0e, 0x12, 0x11, 0x55, 0x8e, 0x51,
        0x30, 0xc8, 0x1c, 0x46, 0xa3, 0x5c, 0xe4, 0x11,
        0xe5, 0xfb, 0xc1, 0x19, 0x1a, 0x0a, 0x52, 0xef,
        0xf6, 0x9f, 0x24, 0x45, 0xdf, 0x4f, 0x9b, 0x17,
        0xad, 0x2b, 0x41, 0x7b, 0xe6, 0x6c, 0x37, 0x10};

    sub_sample_t subSamples[NUM_SUBSAMPLES] = {
        {8, 30},
        {8, 34}};

    printf("TEST #%d DecryptsUnalignedMixedSubSamples\n", test_num);

    TEE_crypto_init();
    attemptDecryptExpectingSuccess(&key, &iv, encrypted, decrypted,
                                   subSamples, NUM_SUBSAMPLES, TOTAL_SIZE);
    TEE_crypto_close();
}

void DecryptsComplexMixedSubSamples(void)
{

#define TOTAL_SIZE 72
#define NUM_SUBSAMPLES 6

    // Based on test vectors from NIST-800-38A
    Key key = {
        .array = {
            0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6,
            0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c},
        .size = AES_BLOCK_SIZE,
        .capacity = AES_BLOCK_SIZE};

    Iv iv = {
        0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7,
        0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff};

    uint8_t encrypted[TOTAL_SIZE] = {
        // 4 clear bytes
        0xf0, 0x13, 0xca, 0xc7,
        // 1 encrypted bytes
        0x87,
        // 9 encrypted bytes
        0x4d, 0x61, 0x91, 0xb6, 0x20, 0xe3, 0x26, 0x1b,
        0xef,
        // 11 clear bytes
        0x81, 0x4f, 0x24, 0x87, 0x0e, 0xde, 0xba, 0xad,
        0x11, 0x9b, 0x46,
        // 20 encrypted bytes
        0x68, 0x64, 0x99, 0x0d, 0xb6, 0xce,
        0x98, 0x06, 0xf6, 0x6b, 0x79, 0x70, 0xfd, 0xff,
        0x86, 0x17, 0x18, 0x7b, 0xb9, 0xff,
        // 8 clear bytes
        0x94, 0xba, 0x88, 0x2e, 0x0e, 0x12, 0x11, 0x55,
        // 3 clear bytes
        0x10, 0xf5, 0x22,
        // 14 encrypted bytes
        0xfd, 0xff, 0x5a, 0xe4, 0xdf, 0x3e, 0xdb, 0xd5,
        0xd3, 0x5e, 0x5b, 0x4f, 0x09, 0x02,
        // 2 clear bytes
        0x02, 0x01};

    uint8_t decrypted[TOTAL_SIZE] = {
        0xf0, 0x13, 0xca, 0xc7, 0x6b, 0xc1, 0xbe, 0xe2,
        0x2e, 0x40, 0x9f, 0x96, 0xe9, 0x3d, 0x81, 0x4f,
        0x24, 0x87, 0x0e, 0xde, 0xba, 0xad, 0x11, 0x9b,
        0x46, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a, 0xae,
        0x2d, 0x8a, 0x57, 0x1e, 0x03, 0xac, 0x9c, 0x9e,
        0xb7, 0x6f, 0xac, 0x45, 0xaf, 0x94, 0xba, 0x88,
        0x2e, 0x0e, 0x12, 0x11, 0x55, 0x10, 0xf5, 0x22,
        0x8e, 0x51, 0x30, 0xc8, 0x1c, 0x46, 0xa3, 0x5c,
        0xe4, 0x11, 0xe5, 0xfb, 0xc1, 0x19, 0x02, 0x01};

    sub_sample_t subSamples[NUM_SUBSAMPLES] = {
        {4, 1},
        {0, 9},
        {11, 20},
        {8, 0},
        {3, 14},
        {2, 0}};

    printf("TEST #%d DecryptsComplexMixedSubSamples\n", test_num);

    TEE_crypto_init();
    attemptDecryptExpectingSuccess(&key, &iv, encrypted, decrypted,
                                   subSamples, NUM_SUBSAMPLES, TOTAL_SIZE);
    TEE_crypto_close();
}

int main()
{
    setvbuf(stdin, NULL, _IONBF, 0);
    setvbuf(stdout, NULL, _IONBF, 0);
    setvbuf(stderr, NULL, _IONBF, 0);

    /* test routine */
    DecryptsContiguousEncryptedBlock();
    DecryptsAlignedBifurcatedEncryptedBlock();
    DecryptsUnalignedBifurcatedEncryptedBlock();
    DecryptsOneMixedSubSample();
    DecryptsAlignedMixedSubSamples();
    DecryptsUnalignedMixedSubSamples();
    DecryptsComplexMixedSubSamples();

    return 0;
}